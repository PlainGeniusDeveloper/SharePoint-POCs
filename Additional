Hereâ€™s the updated code for your previewdataBind function. The update ensures that the custom function will execute only after all promises are resolved and processed:

Updated Code

function previewdataBind(listTitle, paramContentOffering, paramVersion) {
  var listName = listTitle;

  // Step 1: Define Promises
  const fetchProductJson = new Promise((resolve, reject) => {
    getListItems(listTitle, paramContentOffering, paramVersion, function (data) {
      if (publishListDetails.ProductDetails === listTitle || baseListDetails.ProductDetails === listTitle) {
        const items = JSON.parse(data.d.results[0].JSON_x0020_Template);
        resolve({ type: "content-type", data: items }); // Resolve with product-specific JSON
      } else if (publishListDetails.AreaOfSupport === listTitle || baseListDetails.AreaOfSupport === listTitle) {
        const items = data.d.results;
        if (items.length > 0) {
          resolve({ type: "support-cards", data: items }); // Resolve with support-specific data
        } else {
          reject("Area of Support data not found!");
        }
      } else {
        reject("Unsupported list title!");
      }
    });
  });

  const fetchDefaultJson = new Promise((resolve, reject) => {
    const defaultJsonUrl = siteUrl + "/Style Library/Json/product.txt";
    $.get(defaultJsonUrl, function (defaultJsonText) {
      try {
        const defaultJson = JSON.parse(defaultJsonText);
        resolve(defaultJson); // Resolve with default JSON
      } catch (error) {
        reject("Failed to parse default JSON");
      }
    }).fail(function (error) {
      reject(error); // Handle fetch error
    });
  });

  // Step 2: Run Promises and Process Results
  Promise.all([fetchProductJson, fetchDefaultJson])
    .then(async ([productJsonResult, defaultJson]) => {
      // Process results sequentially
      await processResult(productJsonResult, defaultJson);

      // Call custom function after processing all results
      console.log("All results processed. Running custom code...");
      afterAllCompleted();
    })
    .catch((error) => {
      console.error("Error occurred:", error);
    });

  // Function to process a single result
  async function processResult(productJsonResult, defaultJson) {
    if (productJsonResult.type === "content-type") {
      const mergedItems = mergeJSON(defaultJson, productJsonResult.data); // Merge logic
      bindBannerDetails(mergedItems); // Your binding function
    } else if (productJsonResult.type === "support-cards") {
      const supportInfoHtml = contentTypeHandlers["SupportCards"](productJsonResult.data);
      $("#divSupportSlider").append(supportInfoHtml); // Append logic
    } else {
      console.log("Unknown type:", productJsonResult.type);
    }
  }
}


---

Explanation of Updates

1. Sequential Execution:

Used await in the then block to ensure sequential execution of processResult.



2. Custom Function:

afterAllCompleted() is called only after both promises resolve and their results are fully processed.



3. Error Handling:

Added a catch block to handle any errors that occur during promise resolution or result processing.



4. Process Result Logic:

processResult is refactored as an async function for sequential execution when merging or appending data.





---

Flow:

1. Fetch Promises:

Both fetchProductJson and fetchDefaultJson run concurrently.



2. Process Results:

Results are processed sequentially using processResult.



3. Custom Function Execution:

After processing all results, the afterAllCompleted function is called.




This ensures all data is processed before moving forward. Let me know if there are additional adjustments needed!
