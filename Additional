To handle the processing logic in a loop, you can iterate over the results (if there are multiple) and handle each result in sequence, waiting for the processing of each to complete before moving to the next. Here's an updated version with the loop-based approach:

Updated Code with Loop for Processing Results

// Step 3: Run All Operations and Handle Both Scenarios
Promise.all([fetchProductJson, fetchDefaultJson])
    .then(([results, defaultJson]) => processResultsInLoop(results, defaultJson)) // Process results in a loop
    .then(() => {
        // Ensure this runs only after all processing is complete
        runCustomFunction();
    })
    .catch((error) => {
        console.error("Error handling promises:", error);
    });

// Async function to handle results in a loop
async function processResultsInLoop(results, defaultJson) {
    for (const result of results) {
        switch (result.type) {
            case "content-type":
                // Merge product JSON with default JSON
                const mergedItems = mergeJSON(defaultJson, result.data);

                // Await binding banner details
                await bind_banner_details(mergedItems);

                console.log("Content-type processing done for:", result);
                break;

            case "support-cards":
                const supportInfoHtml = contentTypeHandlers["SupportCards"](result.data);

                // Simulate async operation (if necessary)
                await new Promise((resolve) => {
                    $("#divSupportSlider").append(supportInfoHtml);
                    resolve();
                });

                console.log("Support-cards processing done for:", result);
                break;

            default:
                console.warn(`Unhandled type: ${result.type}`);
                // Await if there's some asynchronous task for unhandled types
                await new Promise((resolve) => setTimeout(resolve, 0)); // Dummy async operation
                break;
        }
    }

    // Ensure the function completes asynchronously
    return Promise.resolve();
}

// Custom Function
function runCustomFunction() {
    console.log("All processing is done. Running custom function...");
    // Your custom logic here
}


---

How It Works

1. Iterate with a for...of Loop:

The processResultsInLoop function takes an array of results and processes them one by one.



2. Await for Each Item:

Inside the loop, each result is processed synchronously (one after the other) by awaiting the relevant operation.

Ensures that subsequent iterations only run after the current iteration completes.



3. Handle Multiple Results:

If there are multiple results (e.g., multiple types of JSON responses), each will be processed in sequence.



4. Custom Function Runs After All:

runCustomFunction() will only be called after all results have been processed, ensuring proper flow.





---

Example Output (Expected)

For two results:

Processing content-type for: {type: "content-type", data: {...}}
Content-type processing done for: {type: "content-type", data: {...}}
Processing support-cards for: {type: "support-cards", data: {...}}
Support-cards processing done for: {type: "support-cards", data: {...}}
All processing is done. Running custom function...

This approach ensures that your logic is modular and scalable, handling any number of results while maintaining proper asynchronous flow.
