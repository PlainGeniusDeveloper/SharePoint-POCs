The issue arises because forEach does not await promises by itself. We need to use a for...of loop with await or ensure we collect the promises and await them explicitly before proceeding.

Hereâ€™s how you can properly handle the situation:

Updated Code with for...of:

// Step 3: Run All Operations and Handle Both Scenarios
Promise.all([fetchProductJson, fetchDefaultJson])
  .then(async ([productResult, defaultResult]) => {
    // Wrap the processing in an async function
    const results = [
      { result: productResult, defaultJson: defaultResult }
    ];

    // Iterate over results with a for...of loop to process each result sequentially
    for (const { result, defaultJson } of results) {
      await processResult(result, defaultJson);
    }
  })
  .then(() => {
    // After all results are processed
    console.log("Started custom code");
    afterAllCompleted();
  })
  .catch((error) => {
    // Handle errors
    console.error("Error processing results:", error);
  });

// Process result as an async function
async function processResult(result, defaultJson) {
  if (result.type === "content-type") {
    // Merge product JSON with default JSON
    const mergedItems = mergeJSON(defaultJson, result.data);
    bindBannerDetails(mergedItems);
  } else if (result.type === "support-cards") {
    const supportInfoHtml = contentTypeHandlers["SupportCards"](result.data);
    $("#divSupportSlider").append(supportInfoHtml);
  } else {
    console.warn("Unknown result type:", result.type);
  }
}

Key Points:

1. for...of with await:

The for...of loop ensures that each processResult call completes before moving to the next.

It allows the loop to wait for processResult to finish before continuing.



2. Sequential Execution:

Using await processResult(...) ensures each result is fully processed before moving to the next one.



3. Custom Code Execution:

The .then() after the loop only runs after all results are processed.



4. No Need for Promise.all in Loop:

By using await inside the loop, you handle each promise sequentially.




This ensures the custom function (afterAllCompleted()) only executes after the loop has processed all results completely.
