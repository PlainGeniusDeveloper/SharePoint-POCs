The issue is occurring because Promise.all resolves concurrently for all promises, and even though you are processing the results in sequence (in then), the custom log statements for "All results processed" are being executed for each processed item.

To ensure "All results processed" runs only once after both promises are fully resolved and their results are processed, you can modify the code as follows:

Updated Code

function previewdataBind(listTitle, paramContentOffering, paramVersion) {
  var listName = listTitle;

  // Step 1: Define Promises
  const fetchProductJson = new Promise((resolve, reject) => {
    getListItems(listTitle, paramContentOffering, paramVersion, function (data) {
      if (publishListDetails.ProductDetails === listTitle || baseListDetails.ProductDetails === listTitle) {
        const items = JSON.parse(data.d.results[0].JSON_x0020_Template);
        resolve({ type: "content-type", data: items }); // Resolve with product-specific JSON
      } else if (publishListDetails.AreaOfSupport === listTitle || baseListDetails.AreaOfSupport === listTitle) {
        const items = data.d.results;
        if (items.length > 0) {
          resolve({ type: "support-cards", data: items }); // Resolve with support-specific data
        } else {
          reject("Area of Support data not found!");
        }
      } else {
        reject("Unsupported list title!");
      }
    });
  });

  const fetchDefaultJson = new Promise((resolve, reject) => {
    const defaultJsonUrl = siteUrl + "/Style Library/Json/product.txt";
    $.get(defaultJsonUrl, function (defaultJsonText) {
      try {
        const defaultJson = JSON.parse(defaultJsonText);
        resolve(defaultJson); // Resolve with default JSON
      } catch (error) {
        reject("Failed to parse default JSON");
      }
    }).fail(function (error) {
      reject(error); // Handle fetch error
    });
  });

  // Step 2: Run Promises and Process Results
  Promise.all([fetchProductJson, fetchDefaultJson])
    .then(([productJsonResult, defaultJson]) => {
      // Process results sequentially
      processResult(productJsonResult, defaultJson)
        .then(() => {
          console.log("All results processed."); // Log once after processing
          afterAllCompleted(); // Call custom function after all processing is done
        })
        .catch((error) => {
          console.error("Error during result processing:", error);
        });
    })
    .catch((error) => {
      console.error("Error occurred:", error);
    });

  // Function to process a single result
  async function processResult(productJsonResult, defaultJson) {
    if (productJsonResult.type === "content-type") {
      console.log("Content type process");
      const mergedItems = mergeJSON(defaultJson, productJsonResult.data); // Merge logic
      bindBannerDetails(mergedItems); // Your binding function
    } else if (productJsonResult.type === "support-cards") {
      console.log("Support cards processing");
      const supportInfoHtml = contentTypeHandlers["SupportCards"](productJsonResult.data);
      $("#divSupportSlider").append(supportInfoHtml); // Append logic
    } else {
      console.log("Unknown type:", productJsonResult.type);
    }
  }
}


---

Key Adjustments

1. Consolidated Final Log:

The console.log("All results processed.") is placed after both types of data are processed.



2. Sequential Processing:

The processResult function handles one result at a time, and only after all results are processed, the final log and custom function (afterAllCompleted()) are executed.



3. Removed Duplicate Logs:

Log statements inside processResult ensure individual tasks are logged, while "All results processed" is logged only once.





---

Output

If both promises resolve:

Content type process
Support cards processing
All results processed

If there
