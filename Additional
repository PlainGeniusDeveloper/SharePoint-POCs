Yes, you can absolutely refactor the if-else logic into a separate async function. By doing so, you can use await or return a Promise to ensure the if-else block completes before proceeding to the .then block.

Hereâ€™s how you can refactor it:

Refactored Code Using a Separate Async Function

// Step 3: Run All Operations and Handle Both Scenarios
Promise.all([fetchProductJson, fetchDefaultJson])
    .then(([result, defaultJson]) => processResult(result, defaultJson)) // Call the async function
    .then(() => {
        // Custom function to execute after handling all results
        runCustomFunction();
    })
    .catch((error) => {
        console.error("Error handling promises:", error);
    });

// Async function to handle if-else logic
async function processResult(result, defaultJson) {
    if (result.type === "content-type") {
        // Merge product JSON with default JSON
        const mergedItems = mergeJSON(defaultJson, result.data);

        // Bind banner details (assume this is asynchronous)
        await bind_banner_details(mergedItems); // Make sure this function returns a promise if asynchronous

        console.log("Content-type processing done.");
    } else if (result.type === "support-cards") {
        const supportInfoHtml = contentTypeHandlers["SupportCards"](result.data);

        // Append to the DOM (simulate async operation if needed)
        await new Promise((resolve) => {
            $("#divSupportSlider").append(supportInfoHtml);
            resolve(); // Signal completion
        });

        console.log("Support-cards processing done.");
    }
}

// Custom Function
function runCustomFunction() {
    console.log("All processing is done. Running custom function...");
    // Your custom logic here
}

Explanation of Changes

1. Separate Async Function (processResult):

Handles the if-else logic.

Makes it easier to test and debug.

Uses await to wait for asynchronous operations within each block.



2. Await Asynchronous Operations:

await bind_banner_details(mergedItems) ensures that the function waits for bind_banner_details to complete (it must return a promise for this to work).

For $("#divSupportSlider").append(supportInfoHtml), a manual Promise is used to simulate asynchronous behavior.



3. Wait for Completion in .then:

The .then block will wait for processResult to resolve before proceeding.




Benefits

Clarity: The main Promise.all chain is cleaner and easier to read.

Reusability: You can reuse processResult elsewhere if needed.

Control: Each block within the if-else handles its asynchronous operations independently, and the parent chain waits for completion.


This ensures that the runCustomFunction() will only execute after processResult has fully resolved.
