No, Promise.all doesn't provide a direct way to get the count of resolved promises during its execution. It only resolves when all promises are fulfilled, or rejects as soon as one fails.

However, you can work around this limitation by:

1. Wrapping promises with metadata or tracking their state.


2. Using Promise.allSettled to get information about all promises, including their resolved or rejected state.




---

Using Promise.allSettled to Track Resolved Promises

Promise.allSettled gives detailed information about each promise's state (fulfilled/rejected), allowing you to count the resolved ones.

Example:

function previewdataBind(listTitle, paramContentOffering, paramVersion) {
  var listName = listTitle;

  // Step 1: Define Promises
  const fetchProductJson = new Promise((resolve, reject) => {
    getListItems(listTitle, paramContentOffering, paramVersion, function (data) {
      if (publishListDetails.ProductDetails === listTitle || baseListDetails.ProductDetails === listTitle) {
        const items = JSON.parse(data.d.results[0].JSON_x0020_Template);
        resolve({ type: "content-type", data: items, source: "fetchProductJson" });
      } else if (publishListDetails.AreaOfSupport === listTitle || baseListDetails.AreaOfSupport === listTitle) {
        const items = data.d.results;
        if (items.length > 0) {
          resolve({ type: "support-cards", data: items, source: "fetchProductJson" });
        } else {
          reject("Area of Support data not found!");
        }
      } else {
        reject("Unsupported list title!");
      }
    });
  });

  const fetchDefaultJson = new Promise((resolve, reject) => {
    const defaultJsonUrl = siteUrl + "/Style Library/Json/product.txt";
    $.get(defaultJsonUrl, function (defaultJsonText) {
      try {
        const defaultJson = JSON.parse(defaultJsonText);
        resolve({ data: defaultJson, source: "fetchDefaultJson" });
      } catch (error) {
        reject("Failed to parse default JSON");
      }
    }).fail(function (error) {
      reject(error);
    });
  });

  // Step 2: Use Promise.allSettled
  Promise.allSettled([fetchProductJson, fetchDefaultJson]).then((results) => {
    let resolvedCount = 0;

    results.forEach((result) => {
      if (result.status === "fulfilled") {
        resolvedCount++;
        console.log(`Resolved Promise from: ${result.value.source}`);
        if (result.value.type === "content-type") {
          console.log("Content type process");
          bindBannerDetails(result.value.data); // Handle content type data
        } else if (result.value.type === "support-cards") {
          console.log("Support cards process");
          $("#divSupportSlider").append(contentTypeHandlers["SupportCards"](result.value.data));
        }
      } else {
        console.error(`Rejected Promise: ${result.reason}`);
      }
    });

    console.log(`Total Promises Resolved: ${resolvedCount}`);
    console.log("All promises settled.");
    if (resolvedCount === results.length) {
      console.log("All promises resolved successfully!");
      afterAllCompleted(); // Run your custom function
    }
  });
}


---

Key Notes:

1. Promise.allSettled:

It waits for all promises to either resolve or reject.

Returns an array of objects where each object contains:

status: "fulfilled" or "rejected".

value (if resolved) or reason (if rejected).




2. Resolved Count:

A counter (resolvedCount) is incremented for every fulfilled promise.



3. Processing Rejections:

Rejected promises are logged separately but donâ€™t stop processing other promises.





---

Output Example:

If both promises resolve:

Resolved Promise from: fetchProductJson
Content type process
Resolved Promise from: fetchDefaultJson
Total Promises Resolved: 2
All promises settled.
All promises resolved successfully!

If one promise fails:

Resolved Promise from: fetchProductJson
Content type process
Rejected Promise: Failed to parse default JSON
Total Promises Resolved: 1
All promises settled.

This approach ensures you can count and log each resolved promise while handling failures gracefully.
